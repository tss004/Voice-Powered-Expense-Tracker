"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_64_1 = require("base-64");
exports.minTokenValidTime = 60 * 60 * 1000; // 1 hour
function fetchToken(baseUrl, projectId, appId, deviceId, fetcher = fetch, nowFn = Date.now) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let body;
        if (projectId !== undefined) {
            body = { projectId, deviceId };
        }
        else {
            body = { appId, deviceId };
        }
        const response = yield fetcher(baseUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
        });
        const json = yield response.json();
        if (response.status !== 200) {
            throw Error((_a = json.error) !== null && _a !== void 0 ? _a : `Speechly API login request failed with ${response.status}`);
        }
        if (json.access_token === undefined) {
            throw Error('Invalid login response from Speechly API');
        }
        if (!validateToken(json.access_token, projectId, appId, deviceId, nowFn)) {
            throw Error('Invalid token received from Speechly API');
        }
        return json.access_token;
    });
}
exports.fetchToken = fetchToken;
function validateToken(token, projectId, appId, deviceId, now = Date.now) {
    const decoded = decodeToken(token);
    if (decoded.expiresAtMs - now() < exports.minTokenValidTime) {
        return false;
    }
    if (decoded.appId !== appId || decoded.projectId !== projectId) {
        return false;
    }
    if (decoded.deviceId !== deviceId) {
        return false;
    }
    return true;
}
exports.validateToken = validateToken;
function decodeToken(token) {
    const b = token.split('.')[1];
    let body;
    try {
        body = JSON.parse(base_64_1.decode(b));
    }
    catch (e) {
        throw new Error('Error decoding Speechly token!');
    }
    return {
        appId: body.appId,
        projectId: body.projectId,
        deviceId: body.deviceId,
        configId: body.configId,
        scopes: body.scope.split(' '),
        issuer: body.iss,
        audience: body.aud,
        expiresAtMs: body.exp * 1000,
    };
}
exports.decodeToken = decodeToken;
//# sourceMappingURL=token.js.map