"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const token_1 = require("./token");
describe('token', () => {
    describe('.fetchToken', () => {
        test('returns the token succesfully', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = mockFetch(200, { access_token: testTokenString });
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).resolves.toBe(testTokenString);
        }));
        test('throws if API call fails', () => __awaiter(void 0, void 0, void 0, function* () {
            const err = Error('api-error');
            const f = jest.fn().mockRejectedValue(err);
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).rejects.toThrow(err);
        }));
        test('throws if API returns non-OK status', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = mockFetch(400, { access_token: testTokenString });
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).rejects.toThrow();
        }));
        test('throws if body cannot be read', () => __awaiter(void 0, void 0, void 0, function* () {
            const err = Error('body-error');
            const f = mockFailFetch(500, err);
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).rejects.toThrow(err);
        }));
        test('throws if token is not in response', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = mockFetch(200, {});
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).rejects.toThrow();
        }));
        test('throws if token is invalid', () => __awaiter(void 0, void 0, void 0, function* () {
            const f = mockFetch(200, { access_token: 'some-invalid-token' });
            yield expect(token_1.fetchToken('base-url', testToken.projectId, testToken.appId, testToken.deviceId, f, beforeExpiry(testToken))).rejects.toThrow();
        }));
    });
    describe('.validateToken', () => {
        test('returns true for correct token', () => {
            expect(token_1.validateToken(testTokenString, testToken.projectId, testToken.appId, testToken.deviceId, beforeExpiry(testToken))).toBeTruthy();
        });
        test('returns false when projectId and appId does not match', () => {
            expect(token_1.validateToken(testTokenString, 'other-app-id', testToken.projectId, testToken.deviceId, beforeExpiry(testToken))).toBeFalsy();
        });
        test('returns false when deviceId does not match', () => {
            expect(token_1.validateToken(testTokenString, testToken.projectId, testToken.appId, 'other-device-id', beforeExpiry(testToken))).toBeFalsy();
        });
        test('returns false when token is expired', () => {
            expect(token_1.validateToken(testTokenString, testToken.projectId, testToken.appId, testToken.deviceId, afterExpiry(testToken))).toBeFalsy();
        });
    });
    describe('.decodeToken', () => {
        test('decodes test token correctly', () => {
            expect(token_1.decodeToken(testTokenString)).toMatchObject(testToken);
        });
        test('throws when token is invalid', () => {
            expect(() => {
                token_1.decodeToken('123456');
            }).toThrow();
        });
        test('throws when token is not base64 encoded', () => {
            expect(() => {
                token_1.decodeToken('123456.$$$$$$$@@@@@@@.123456');
            }).toThrow();
        });
        test('throws when token is not serialised JSON', () => {
            expect(() => {
                token_1.decodeToken('123456.123456.123456');
            }).toThrow();
        });
    });
});
const testTokenString = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcHBJZCI6IjAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCIsInByb2plY3RJZCI6IjExMTExMTExLTExMTEtMTExMS0xMTExLTExMTExMTExMTExMSIsImRldmljZUlkIjoiMTExMTExMTEtMTExMS0xMTExLTExMTEtMTExMTExMTExMTExIiwic2NvcGUiOiJzbHUiLCJleHAiOjE1OTkzMTM2NTYsImNvbmZpZ0lkIjoiMTExMTExMTEtMTExMS0xMTExLTExMTEtMTExMTExMTExMTExIiwiaXNzIjoiaHR0cHM6Ly9hcGkuc3BlZWNobHkuY29tLyIsImF1ZCI6Imh0dHBzOi8vYXBpLnNwZWVjaGx5LmNvbS8ifQ.QqqxerSCgGAReMwS2losF276sJ6vnoPhXn-bbrKgoMU';
const testToken = {
    appId: '00000000-0000-0000-0000-000000000000',
    projectId: '11111111-1111-1111-1111-111111111111',
    deviceId: '11111111-1111-1111-1111-111111111111',
    configId: '11111111-1111-1111-1111-111111111111',
    scopes: ['slu'],
    issuer: 'https://api.speechly.com/',
    audience: 'https://api.speechly.com/',
    expiresAtMs: 1599313656000,
};
function mockFetch(status, data) {
    const response = { status, json: () => __awaiter(this, void 0, void 0, function* () { return Promise.resolve(data); }) };
    return jest.fn().mockResolvedValue(response);
}
function mockFailFetch(status, err) {
    const response = { status, json: () => __awaiter(this, void 0, void 0, function* () { return Promise.reject(err); }) };
    return jest.fn().mockResolvedValue(response);
}
function beforeExpiry(t) {
    return jest.fn().mockReturnValue(t.expiresAtMs - token_1.minTokenValidTime);
}
function afterExpiry(t) {
    return jest.fn().mockReturnValue(t.expiresAtMs);
}
//# sourceMappingURL=token.test.js.map