"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const worker_1 = __importDefault(require("./worker"));
class WebWorkerController {
    constructor() {
        this.startCbs = [];
        this.stopCbs = [];
        this.onResponseCb = () => { };
        this.onCloseCb = () => { };
        this.onWebsocketMessage = (event) => {
            const response = event.data;
            switch (response.type) {
                case types_1.WebsocketResponseType.Opened:
                    if (this.resolveInitialization != null) {
                        this.resolveInitialization();
                    }
                    break;
                case types_1.WebsocketResponseType.SourceSampleRateSetSuccess:
                    if (this.resolveSourceSampleRateSet != null) {
                        this.resolveSourceSampleRateSet();
                    }
                    break;
                case types_1.WebsocketResponseType.Started:
                    this.startCbs.forEach(cb => {
                        try {
                            cb(undefined, response.audio_context);
                        }
                        catch (e) {
                            console.error('[SpeechlyClient] Error while invoking "onStart" callback:', e);
                        }
                    });
                    this.startCbs.length = 0;
                    break;
                case types_1.WebsocketResponseType.Stopped:
                    this.stopCbs.forEach(cb => {
                        try {
                            cb(undefined, response.audio_context);
                        }
                        catch (e) {
                            console.error('[SpeechlyClient] Error while invoking "onStop" callback:', e);
                        }
                    });
                    this.stopCbs.length = 0;
                    break;
                default:
                    this.onResponseCb(response);
            }
        };
        const blob = new Blob([worker_1.default], { type: 'text/javascript' });
        const blobURL = window.URL.createObjectURL(blob);
        this.worker = new Worker(blobURL);
        this.worker.addEventListener('message', this.onWebsocketMessage);
    }
    onResponse(cb) {
        this.onResponseCb = cb;
    }
    onClose(cb) {
        this.onCloseCb = cb;
    }
    initialize(apiUrl, authToken, targetSampleRate, debug) {
        return __awaiter(this, void 0, void 0, function* () {
            this.worker.postMessage({
                type: 'INIT',
                apiUrl,
                authToken,
                targetSampleRate,
                debug,
            });
            return new Promise(resolve => {
                this.resolveInitialization = resolve;
            });
        });
    }
    setSourceSampleRate(sourceSampleRate) {
        return __awaiter(this, void 0, void 0, function* () {
            this.worker.postMessage({
                type: 'SET_SOURSE_SAMPLE_RATE',
                sourceSampleRate,
            });
            return new Promise(resolve => {
                this.resolveSourceSampleRateSet = resolve;
            });
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.worker.postMessage({
                    type: 'CLOSE',
                    code: 1000,
                    message: 'Client has ended the session',
                });
                resolve();
            });
        });
    }
    startContext(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.startCbs.push((err, id) => {
                    if (err !== undefined) {
                        reject(err);
                    }
                    else {
                        resolve(id);
                    }
                });
                if (appId != null) {
                    this.worker.postMessage({ type: 'START_CONTEXT', appId });
                }
                else {
                    this.worker.postMessage({ type: 'START_CONTEXT' });
                }
            });
        });
    }
    stopContext() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.stopCbs.push((err, id) => {
                    if (err !== undefined) {
                        reject(err);
                    }
                    else {
                        resolve(id);
                    }
                });
                this.worker.postMessage({ type: 'STOP_CONTEXT' });
            });
        });
    }
    switchContext(appId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.startCbs.push((err, id) => {
                    if (err !== undefined) {
                        reject(err);
                    }
                    else {
                        resolve(id);
                    }
                });
                this.worker.postMessage({ type: 'SWITCH_CONTEXT', appId });
            });
        });
    }
    postMessage(message) {
        this.worker.postMessage(message);
    }
    sendAudio(audioChunk) {
        this.worker.postMessage({ type: 'AUDIO', payload: audioChunk });
    }
}
exports.WebWorkerController = WebWorkerController;
//# sourceMappingURL=webWorkerController.js.map