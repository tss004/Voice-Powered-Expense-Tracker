"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class SegmentState {
    constructor(ctxId, sId) {
        this.isFinalized = false;
        this.words = [];
        this.entities = new Map();
        this.intent = { intent: '', isFinal: false };
        this.contextId = ctxId;
        this.id = sId;
    }
    toSegment() {
        let i = 0;
        const entities = new Array(this.entities.size);
        this.entities.forEach(v => {
            entities[i] = v;
            i++;
        });
        return {
            id: this.id,
            contextId: this.contextId,
            isFinal: this.isFinalized,
            words: this.words,
            entities: entities,
            intent: this.intent,
        };
    }
    toString() {
        const segment = this.toSegment();
        const words = segment.words.filter((w) => w.value).map((w) => ({ value: w.value, index: w.index }));
        const cleanSegment = Object.assign(Object.assign({}, segment), { words });
        return JSON.stringify(cleanSegment, null, 2);
    }
    updateTranscript(words) {
        words.forEach(w => {
            // Only accept tentative words if the segment is tentative.
            if (!this.isFinalized || w.isFinal) {
                this.words[w.index] = w;
            }
        });
        return this;
    }
    updateEntities(entities) {
        entities.forEach(e => {
            // Only accept tentative entities if the segment is tentative.
            if (!this.isFinalized || e.isFinal) {
                this.entities.set(entityMapKey(e), e);
            }
        });
        return this;
    }
    updateIntent(intent) {
        // Only accept tentative intent if the segment is tentative.
        if (!this.isFinalized || intent.isFinal) {
            this.intent = intent;
        }
        return this;
    }
    finalize() {
        // Filter away any entities which were not finalized.
        this.entities.forEach((val, key) => {
            if (!val.isFinal) {
                this.entities.delete(key);
            }
        });
        // Filter away any transcripts which were not finalized.
        this.words = this.words.filter(w => w.isFinal);
        if (!this.intent.isFinal) {
            this.intent.intent = '';
            this.intent.isFinal = true;
        }
        // Mark as final.
        this.isFinalized = true;
        return this;
    }
}
exports.SegmentState = SegmentState;
function entityMapKey(e) {
    return `${e.startPosition.toString()}:${e.endPosition.toString()}`;
}
//# sourceMappingURL=segment.js.map