{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst {\n  FileCoverage\n} = require('./file-coverage');\n\nconst {\n  CoverageSummary\n} = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n  if (obj instanceof klass) {\n    return obj;\n  }\n\n  return new klass(obj);\n}\n\nfunction loadMap(source) {\n  const data = Object.create(null);\n\n  if (!source) {\n    return data;\n  }\n\n  Object.entries(source).forEach(([k, cov]) => {\n    data[k] = maybeConstruct(cov, FileCoverage);\n  });\n  return data;\n}\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\n\n\nclass CoverageMap {\n  /**\n   * @constructor\n   * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n   * map's contents. This can be the raw global coverage object.\n   */\n  constructor(obj) {\n    if (obj instanceof CoverageMap) {\n      this.data = obj.data;\n    } else {\n      this.data = loadMap(obj);\n    }\n  }\n  /**\n   * merges a second coverage map into this one\n   * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n   *  correctly for the same files and additional file coverage keys are created\n   *  as needed.\n   */\n\n\n  merge(obj) {\n    const other = maybeConstruct(obj, CoverageMap);\n    Object.values(other.data).forEach(fc => {\n      this.addFileCoverage(fc);\n    });\n  }\n  /**\n   * filter the coveragemap based on the callback provided\n   * @param {Function (filename)} callback - Returns true if the path\n   *  should be included in the coveragemap. False if it should be\n   *  removed.\n   */\n\n\n  filter(callback) {\n    Object.keys(this.data).forEach(k => {\n      if (!callback(k)) {\n        delete this.data[k];\n      }\n    });\n  }\n  /**\n   * returns a JSON-serializable POJO for this coverage map\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return this.data;\n  }\n  /**\n   * returns an array for file paths for which this map has coverage\n   * @returns {Array{string}} - array of files\n   */\n\n\n  files() {\n    return Object.keys(this.data);\n  }\n  /**\n   * returns the file coverage for the specified file.\n   * @param {String} file\n   * @returns {FileCoverage}\n   */\n\n\n  fileCoverageFor(file) {\n    const fc = this.data[file];\n\n    if (!fc) {\n      throw new Error(`No file coverage available for: ${file}`);\n    }\n\n    return fc;\n  }\n  /**\n   * adds a file coverage object to this map. If the path for the object,\n   * already exists in the map, it is merged with the existing coverage\n   * otherwise a new key is added to the map.\n   * @param {FileCoverage} fc the file coverage to add\n   */\n\n\n  addFileCoverage(fc) {\n    const cov = new FileCoverage(fc);\n    const {\n      path\n    } = cov;\n\n    if (this.data[path]) {\n      this.data[path].merge(cov);\n    } else {\n      this.data[path] = cov;\n    }\n  }\n  /**\n   * returns the coverage summary for all the file coverage objects in this map.\n   * @returns {CoverageSummary}\n   */\n\n\n  getCoverageSummary() {\n    const ret = new CoverageSummary();\n    Object.values(this.data).forEach(fc => {\n      ret.merge(fc.toSummary());\n    });\n    return ret;\n  }\n\n}\n\nmodule.exports = {\n  CoverageMap\n};","map":{"version":3,"sources":["C:/Users/hp/Desktop/expensetracker/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"names":["FileCoverage","require","CoverageSummary","maybeConstruct","obj","klass","loadMap","source","data","Object","create","entries","forEach","k","cov","CoverageMap","constructor","merge","other","values","fc","addFileCoverage","filter","callback","keys","toJSON","files","fileCoverageFor","file","Error","path","getCoverageSummary","ret","toSummary","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('./file-coverage');\nconst { CoverageSummary } = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n    if (obj instanceof klass) {\n        return obj;\n    }\n\n    return new klass(obj);\n}\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    if (!source) {\n        return data;\n    }\n\n    Object.entries(source).forEach(([k, cov]) => {\n        data[k] = maybeConstruct(cov, FileCoverage);\n    });\n\n    return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n    /**\n     * @constructor\n     * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n     * map's contents. This can be the raw global coverage object.\n     */\n    constructor(obj) {\n        if (obj instanceof CoverageMap) {\n            this.data = obj.data;\n        } else {\n            this.data = loadMap(obj);\n        }\n    }\n\n    /**\n     * merges a second coverage map into this one\n     * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n     *  correctly for the same files and additional file coverage keys are created\n     *  as needed.\n     */\n    merge(obj) {\n        const other = maybeConstruct(obj, CoverageMap);\n        Object.values(other.data).forEach(fc => {\n            this.addFileCoverage(fc);\n        });\n    }\n\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n    filter(callback) {\n        Object.keys(this.data).forEach(k => {\n            if (!callback(k)) {\n                delete this.data[k];\n            }\n        });\n    }\n\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n    files() {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n    fileCoverageFor(file) {\n        const fc = this.data[file];\n        if (!fc) {\n            throw new Error(`No file coverage available for: ${file}`);\n        }\n        return fc;\n    }\n\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n    addFileCoverage(fc) {\n        const cov = new FileCoverage(fc);\n        const { path } = cov;\n        if (this.data[path]) {\n            this.data[path].merge(cov);\n        } else {\n            this.data[path] = cov;\n        }\n    }\n\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n    getCoverageSummary() {\n        const ret = new CoverageSummary();\n        Object.values(this.data).forEach(fc => {\n            ret.merge(fc.toSummary());\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {\n    CoverageMap\n};\n"]},"metadata":{},"sourceType":"script"}