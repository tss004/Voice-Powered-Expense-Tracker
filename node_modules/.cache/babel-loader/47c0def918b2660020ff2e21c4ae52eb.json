{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/Users/hp/Desktop/Projects/Expense-Tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/hp/Desktop/Projects/Expense-Tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar SegmentState = /*#__PURE__*/function () {\n  function SegmentState(ctxId, sId) {\n    _classCallCheck(this, SegmentState);\n\n    this.isFinalized = false;\n    this.words = [];\n    this.entities = new Map();\n    this.intent = {\n      intent: '',\n      isFinal: false\n    };\n    this.contextId = ctxId;\n    this.id = sId;\n  }\n\n  _createClass(SegmentState, [{\n    key: \"toSegment\",\n    value: function toSegment() {\n      var i = 0;\n      var entities = new Array(this.entities.size);\n      this.entities.forEach(function (v) {\n        entities[i] = v;\n        i++;\n      });\n      return {\n        id: this.id,\n        contextId: this.contextId,\n        isFinal: this.isFinalized,\n        words: this.words,\n        entities: entities,\n        intent: this.intent\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var segment = this.toSegment();\n      var words = segment.words.filter(function (w) {\n        return w.value;\n      }).map(function (w) {\n        return {\n          value: w.value,\n          index: w.index\n        };\n      });\n      var cleanSegment = Object.assign(Object.assign({}, segment), {\n        words: words\n      });\n      return JSON.stringify(cleanSegment, null, 2);\n    }\n  }, {\n    key: \"updateTranscript\",\n    value: function updateTranscript(words) {\n      var _this = this;\n\n      words.forEach(function (w) {\n        // Only accept tentative words if the segment is tentative.\n        if (!_this.isFinalized || w.isFinal) {\n          _this.words[w.index] = w;\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"updateEntities\",\n    value: function updateEntities(entities) {\n      var _this2 = this;\n\n      entities.forEach(function (e) {\n        // Only accept tentative entities if the segment is tentative.\n        if (!_this2.isFinalized || e.isFinal) {\n          _this2.entities.set(entityMapKey(e), e);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"updateIntent\",\n    value: function updateIntent(intent) {\n      // Only accept tentative intent if the segment is tentative.\n      if (!this.isFinalized || intent.isFinal) {\n        this.intent = intent;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      var _this3 = this;\n\n      // Filter away any entities which were not finalized.\n      this.entities.forEach(function (val, key) {\n        if (!val.isFinal) {\n          _this3.entities.delete(key);\n        }\n      }); // Filter away any transcripts which were not finalized.\n\n      this.words = this.words.filter(function (w) {\n        return w.isFinal;\n      });\n\n      if (!this.intent.isFinal) {\n        this.intent.intent = '';\n        this.intent.isFinal = true;\n      } // Mark as final.\n\n\n      this.isFinalized = true;\n      return this;\n    }\n  }]);\n\n  return SegmentState;\n}();\n\nexports.SegmentState = SegmentState;\n\nfunction entityMapKey(e) {\n  return \"\".concat(e.startPosition.toString(), \":\").concat(e.endPosition.toString());\n}","map":{"version":3,"sources":["../../src/speechly/segment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SegmentState {\n    constructor(ctxId, sId) {\n        this.isFinalized = false;\n        this.words = [];\n        this.entities = new Map();\n        this.intent = { intent: '', isFinal: false };\n        this.contextId = ctxId;\n        this.id = sId;\n    }\n    toSegment() {\n        let i = 0;\n        const entities = new Array(this.entities.size);\n        this.entities.forEach(v => {\n            entities[i] = v;\n            i++;\n        });\n        return {\n            id: this.id,\n            contextId: this.contextId,\n            isFinal: this.isFinalized,\n            words: this.words,\n            entities: entities,\n            intent: this.intent,\n        };\n    }\n    toString() {\n        const segment = this.toSegment();\n        const words = segment.words.filter((w) => w.value).map((w) => ({ value: w.value, index: w.index }));\n        const cleanSegment = Object.assign(Object.assign({}, segment), { words });\n        return JSON.stringify(cleanSegment, null, 2);\n    }\n    updateTranscript(words) {\n        words.forEach(w => {\n            // Only accept tentative words if the segment is tentative.\n            if (!this.isFinalized || w.isFinal) {\n                this.words[w.index] = w;\n            }\n        });\n        return this;\n    }\n    updateEntities(entities) {\n        entities.forEach(e => {\n            // Only accept tentative entities if the segment is tentative.\n            if (!this.isFinalized || e.isFinal) {\n                this.entities.set(entityMapKey(e), e);\n            }\n        });\n        return this;\n    }\n    updateIntent(intent) {\n        // Only accept tentative intent if the segment is tentative.\n        if (!this.isFinalized || intent.isFinal) {\n            this.intent = intent;\n        }\n        return this;\n    }\n    finalize() {\n        // Filter away any entities which were not finalized.\n        this.entities.forEach((val, key) => {\n            if (!val.isFinal) {\n                this.entities.delete(key);\n            }\n        });\n        // Filter away any transcripts which were not finalized.\n        this.words = this.words.filter(w => w.isFinal);\n        if (!this.intent.isFinal) {\n            this.intent.intent = '';\n            this.intent.isFinal = true;\n        }\n        // Mark as final.\n        this.isFinalized = true;\n        return this;\n    }\n}\nexports.SegmentState = SegmentState;\nfunction entityMapKey(e) {\n    return `${e.startPosition.toString()}:${e.endPosition.toString()}`;\n}\n//# sourceMappingURL=segment.js.map"]},"metadata":{},"sourceType":"script"}