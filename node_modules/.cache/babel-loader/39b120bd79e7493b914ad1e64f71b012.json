{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:/Users/hp/Desktop/Projects/Expense-Tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"C:/Users/hp/Desktop/Projects/Expense-Tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/hp/Desktop/Projects/Expense-Tracker/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar locale_code_1 = __importDefault(require(\"locale-code\"));\n\nvar uuid_1 = require(\"uuid\");\n\nvar token_1 = require(\"../websocket/token\");\n\nvar microphone_1 = require(\"../microphone\");\n\nvar websocket_1 = require(\"../websocket\");\n\nvar storage_1 = require(\"../storage\");\n\nvar types_1 = require(\"./types\");\n\nvar state_1 = require(\"./state\");\n\nvar segment_1 = require(\"./segment\");\n\nvar parsers_1 = require(\"./parsers\");\n\nvar async_retry_1 = __importDefault(require(\"async-retry\"));\n\nvar deviceIdStorageKey = 'speechly-device-id';\nvar authTokenKey = 'speechly-auth-token';\nvar defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nvar defaultLoginUrl = 'https://api.speechly.com/login';\nvar defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\n\nvar Client = /*#__PURE__*/function () {\n  function Client(options) {\n    var _this = this;\n\n    _classCallCheck(this, Client);\n\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n    this.activeContexts = new Map();\n    this.reconnectAttemptCount = 5;\n    this.reconnectMinDelay = 1000;\n    this.contextStopDelay = 250;\n    this.state = types_1.ClientState.Disconnected;\n\n    this.stateChangeCb = function () {};\n\n    this.segmentChangeCb = function () {};\n\n    this.tentativeTranscriptCb = function () {};\n\n    this.tentativeEntitiesCb = function () {};\n\n    this.tentativeIntentCb = function () {};\n\n    this.transcriptCb = function () {};\n\n    this.entityCb = function () {};\n\n    this.intentCb = function () {};\n\n    this.handleWebsocketResponse = function (response) {\n      var _a;\n\n      if (_this.debug) {\n        console.log('[SpeechlyClient]', 'Received response', response);\n      } // eslint-disable-next-line @typescript-eslint/camelcase\n\n\n      var audio_context = response.audio_context,\n          segment_id = response.segment_id,\n          type = response.type;\n      var data = response.data;\n\n      var context = _this.activeContexts.get(audio_context);\n\n      if (context === undefined) {\n        console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n        return;\n      }\n\n      var segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n\n      switch (type) {\n        case websocket_1.WebsocketResponseType.TentativeTranscript:\n          data = data;\n          var words = parsers_1.parseTentativeTranscript(data);\n\n          _this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n\n          segmentState = segmentState.updateTranscript(words);\n          break;\n\n        case websocket_1.WebsocketResponseType.Transcript:\n          data = data;\n          var word = parsers_1.parseTranscript(data);\n\n          _this.transcriptCb(audio_context, segment_id, word);\n\n          segmentState = segmentState.updateTranscript([word]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeEntities:\n          data = data;\n          var entities = parsers_1.parseTentativeEntities(data);\n\n          _this.tentativeEntitiesCb(audio_context, segment_id, entities);\n\n          segmentState = segmentState.updateEntities(entities);\n          break;\n\n        case websocket_1.WebsocketResponseType.Entity:\n          data = data;\n          var entity = parsers_1.parseEntity(data);\n\n          _this.entityCb(audio_context, segment_id, entity);\n\n          segmentState = segmentState.updateEntities([entity]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeIntent:\n          data = data;\n          var tentativeIntent = parsers_1.parseIntent(data, false);\n\n          _this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n\n          segmentState = segmentState.updateIntent(tentativeIntent);\n          break;\n\n        case websocket_1.WebsocketResponseType.Intent:\n          data = data;\n          var intent = parsers_1.parseIntent(data, true);\n\n          _this.intentCb(audio_context, segment_id, intent);\n\n          segmentState = segmentState.updateIntent(intent);\n          break;\n\n        case websocket_1.WebsocketResponseType.SegmentEnd:\n          segmentState = segmentState.finalize();\n          break;\n\n        default: // TODO: handle unexpected response types.\n\n      } // Update the segment in current context.\n\n\n      context.set(segment_id, segmentState); // Update current contexts.\n\n      _this.activeContexts.set(audio_context, context); // Log segment to console\n\n\n      if (_this.logSegments) {\n        console.info(segmentState.toString());\n      } // Fire segment change event.\n\n\n      _this.segmentChangeCb(segmentState.toSegment());\n    };\n\n    this.handleWebsocketClosure = function (err) {\n      if (_this.debug) {\n        console.error('[SpeechlyClient]', 'Server connection closed', err);\n      } // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n\n\n      if (_this.deviceId === undefined) {\n        _this.setState(types_1.ClientState.Failed);\n\n        return;\n      } // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n\n\n      if (_this.state === types_1.ClientState.Connecting || _this.state === types_1.ClientState.Failed) {\n        return;\n      }\n\n      _this.setState(types_1.ClientState.Connecting);\n\n      _this.reconnectWebsocket(_this.deviceId).then(function () {\n        return _this.setState(types_1.ClientState.Connected);\n      }).catch(function () {\n        return _this.setState(types_1.ClientState.Failed);\n      });\n    };\n\n    this.sampleRate = (_a = options.sampleRate) !== null && _a !== void 0 ? _a : microphone_1.DefaultSampleRate;\n\n    try {\n      var constraints = window.navigator.mediaDevices.getSupportedConstraints();\n      this.nativeResamplingSupported = constraints.sampleRate === true;\n    } catch (_o) {\n      this.nativeResamplingSupported = false;\n    }\n\n    var language = (_b = options.language) !== null && _b !== void 0 ? _b : defaultLanguage;\n\n    if (!locale_code_1.default.validate(language)) {\n      throw Error(\"[SpeechlyClient] Invalid language \\\"\".concat(language, \"\\\"\"));\n    }\n\n    this.debug = (_c = options.debug) !== null && _c !== void 0 ? _c : false;\n    this.logSegments = (_d = options.logSegments) !== null && _d !== void 0 ? _d : false;\n    this.loginUrl = (_e = options.loginUrl) !== null && _e !== void 0 ? _e : defaultLoginUrl;\n    this.appId = (_f = options.appId) !== null && _f !== void 0 ? _f : undefined;\n    this.projectId = (_g = options.projectId) !== null && _g !== void 0 ? _g : undefined;\n    var apiUrl = generateWsUrl((_h = options.apiUrl) !== null && _h !== void 0 ? _h : defaultApiUrl, language, (_j = options.sampleRate) !== null && _j !== void 0 ? _j : microphone_1.DefaultSampleRate);\n    this.apiClient = (_k = options.apiClient) !== null && _k !== void 0 ? _k : new websocket_1.WebWorkerController();\n    this.storage = (_l = options.storage) !== null && _l !== void 0 ? _l : new storage_1.LocalStorage();\n    this.deviceId = this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n    var storedToken = this.storage.get(authTokenKey); // 2. Fetch auth token. It doesn't matter if it's not present.\n\n    this.initializeApiClientPromise = new Promise(function (resolve) {\n      _this.resolveInitialization = resolve;\n    });\n\n    if (storedToken == null || !token_1.validateToken(storedToken, this.projectId, this.appId, this.deviceId)) {\n      token_1.fetchToken(this.loginUrl, this.projectId, this.appId, this.deviceId).then(function (token) {\n        _this.authToken = token; // Cache the auth token in local storage for future use.\n\n        _this.storage.set(authTokenKey, _this.authToken);\n\n        _this.connect(apiUrl);\n      }).catch(function (err) {\n        throw err;\n      });\n    } else {\n      this.authToken = storedToken;\n      this.connect(apiUrl);\n    }\n\n    if (window.AudioContext !== undefined) {\n      this.isWebkit = false;\n    } else if (window.webkitAudioContext !== undefined) {\n      this.isWebkit = true;\n    } else {\n      throw microphone_1.ErrDeviceNotSupported;\n    }\n\n    this.microphone = (_m = options.microphone) !== null && _m !== void 0 ? _m : new microphone_1.BrowserMicrophone(this.isWebkit, this.sampleRate, this.apiClient, this.debug);\n    this.apiClient.onResponse(this.handleWebsocketResponse);\n    this.apiClient.onClose(this.handleWebsocketClosure);\n    window.SpeechlyClient = this;\n  }\n  /**\n   * Esteblish websocket connection\n   */\n\n\n  _createClass(Client, [{\n    key: \"connect\",\n    value: function connect(apiUrl) {\n      var _this2 = this;\n\n      if (this.authToken != null) {\n        this.apiClient.initialize(apiUrl, this.authToken, this.sampleRate, this.debug).then(function () {\n          if (_this2.resolveInitialization != null) {\n            _this2.resolveInitialization();\n          }\n        }).catch(function (err) {\n          throw err;\n        });\n      }\n    }\n    /**\n     * Initializes the client, by initializing the microphone and establishing connection to the API.\n     *\n     * This function HAS to be invoked by a user by e.g. binding it to a button press,\n     * or some other user-performed action.\n     *\n     * If this function is invoked without a user interaction,\n     * the microphone functionality will not work due to security restrictions by the browser.\n     */\n\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _opts, opts;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.initializeApiClientPromise;\n\n              case 2:\n                if (!(this.state !== types_1.ClientState.Disconnected)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw Error('Cannot initialize client - client is not in Disconnected state');\n\n              case 4:\n                this.setState(types_1.ClientState.Connecting);\n                _context.prev = 5;\n\n                // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n                // await this.storage.initialize()\n                // this.deviceId = await this.storage.getOrSet(deviceIdStorageKey, uuidv4)\n                // 2. Initialise the microphone stack.\n                if (this.isWebkit) {\n                  if (window.webkitAudioContext !== undefined) {\n                    // eslint-disable-next-line new-cap\n                    this.audioContext = new window.webkitAudioContext();\n                  }\n                } else {\n                  _opts = {};\n\n                  if (this.nativeResamplingSupported) {\n                    _opts.sampleRate = this.sampleRate;\n                  }\n\n                  this.audioContext = new window.AudioContext(_opts);\n                }\n\n                opts = {\n                  video: false\n                };\n\n                if (this.nativeResamplingSupported) {\n                  opts.audio = {\n                    sampleRate: this.sampleRate\n                  };\n                } else {\n                  opts.audio = true;\n                }\n\n                if (!(this.audioContext != null)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!this.isWebkit) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return this.audioContext.resume();\n\n              case 13:\n                _context.next = 15;\n                return this.apiClient.setSourceSampleRate(this.audioContext.sampleRate);\n\n              case 15:\n                this.initializeMicrophonePromise = this.microphone.initialize(this.audioContext, opts);\n                _context.next = 18;\n                return this.initializeMicrophonePromise;\n\n              case 18:\n                _context.next = 21;\n                break;\n\n              case 20:\n                throw microphone_1.ErrDeviceNotSupported;\n\n              case 21:\n                _context.next = 34;\n                break;\n\n              case 23:\n                _context.prev = 23;\n                _context.t0 = _context[\"catch\"](5);\n                _context.t1 = _context.t0;\n                _context.next = _context.t1 === microphone_1.ErrDeviceNotSupported ? 28 : _context.t1 === microphone_1.ErrNoAudioConsent ? 30 : 32;\n                break;\n\n              case 28:\n                this.setState(types_1.ClientState.NoBrowserSupport);\n                return _context.abrupt(\"break\", 33);\n\n              case 30:\n                this.setState(types_1.ClientState.NoAudioConsent);\n                return _context.abrupt(\"break\", 33);\n\n              case 32:\n                this.setState(types_1.ClientState.Failed);\n\n              case 33:\n                throw _context.t0;\n\n              case 34:\n                this.setState(types_1.ClientState.Connected);\n\n              case 35:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 23]]);\n      }));\n    }\n    /**\n     * Closes the client by closing the API connection and disabling the microphone.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var errs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                errs = [];\n                _context2.prev = 1;\n                _context2.next = 4;\n                return this.microphone.close();\n\n              case 4:\n                _context2.next = 9;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](1);\n                errs.push(_context2.t0.message);\n\n              case 9:\n                _context2.prev = 9;\n                _context2.next = 12;\n                return this.apiClient.close();\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t1 = _context2[\"catch\"](9);\n                errs.push(_context2.t1.message);\n\n              case 17:\n                this.activeContexts.clear();\n                this.setState(types_1.ClientState.Disconnected);\n\n                if (!(errs.length > 0)) {\n                  _context2.next = 21;\n                  break;\n                }\n\n                throw Error(errs.join(','));\n\n              case 21:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 6], [9, 14]]);\n      }));\n    }\n    /**\n     * Stops current context and immediately starts a new SLU context\n     * by sending a start context event to the API and unmuting the microphone.\n     * @param appId - unique identifier of an app in the dashboard.\n     */\n\n  }, {\n    key: \"switchContext\",\n    value: function switchContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!(this.state === types_1.ClientState.Recording)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                this.resolveStopContext = undefined;\n                _context3.next = 4;\n                return this.apiClient.switchContext(appId);\n\n              case 4:\n                contextId = _context3.sent;\n                this.activeContexts.set(contextId, new Map());\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n     * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n     */\n\n  }, {\n    key: \"startContext\",\n    value: function startContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.resolveStopContext != null)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                this.resolveStopContext();\n                _context4.next = 4;\n                return this.stoppedContextIdPromise;\n\n              case 4:\n                if (!(this.state === types_1.ClientState.Disconnected || this.state === types_1.ClientState.Connecting)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw Error('Cannot start context - client is not connected');\n\n              case 6:\n                this.setState(types_1.ClientState.Starting);\n                _context4.next = 9;\n                return this._startContext(appId);\n\n              case 9:\n                contextId = _context4.sent;\n                return _context4.abrupt(\"return\", contextId);\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"_startContext\",\n    value: function _startContext(appId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n\n                if (!(this.projectId != null)) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                _context5.next = 4;\n                return this.apiClient.startContext(appId);\n\n              case 4:\n                contextId = _context5.sent;\n                _context5.next = 10;\n                break;\n\n              case 7:\n                _context5.next = 9;\n                return this.apiClient.startContext();\n\n              case 9:\n                contextId = _context5.sent;\n\n              case 10:\n                _context5.next = 16;\n                break;\n\n              case 12:\n                _context5.prev = 12;\n                _context5.t0 = _context5[\"catch\"](0);\n                this.setState(types_1.ClientState.Connected);\n                throw _context5.t0;\n\n              case 16:\n                this.setState(types_1.ClientState.Recording);\n                this.microphone.unmute();\n                this.activeContexts.set(contextId, new Map());\n                return _context5.abrupt(\"return\", contextId);\n\n              case 20:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Stops current SLU context by sending a stop context event to the API and muting the microphone\n     * delayed by contextStopDelay = 250 ms\n     */\n\n  }, {\n    key: \"stopContext\",\n    value: function stopContext() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this3 = this;\n\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this.state !== types_1.ClientState.Recording && this.state !== types_1.ClientState.Starting)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw Error('Cannot stop context - client is not recording');\n\n              case 2:\n                this.setState(types_1.ClientState.Stopping);\n                this.stoppedContextIdPromise = new Promise(function (resolve) {\n                  Promise.race([new Promise(function (resolve) {\n                    return setTimeout(resolve, _this3.contextStopDelay);\n                  }), new Promise(function (resolve) {\n                    _this3.resolveStopContext = resolve;\n                  })]).then(function () {\n                    _this3._stopContext().then(function (id) {\n                      resolve(id);\n                    }).catch(function (err) {\n                      throw err;\n                    });\n                  }).catch(function (err) {\n                    throw err;\n                  });\n                });\n                _context6.next = 6;\n                return this.stoppedContextIdPromise;\n\n              case 6:\n                contextId = _context6.sent;\n                this.setState(types_1.ClientState.Connected);\n                this.activeContexts.delete(contextId);\n                return _context6.abrupt(\"return\", contextId);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"_stopContext\",\n    value: function _stopContext() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var contextId;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this.microphone.mute();\n                _context7.prev = 1;\n                _context7.next = 4;\n                return this.apiClient.stopContext();\n\n              case 4:\n                contextId = _context7.sent;\n                _context7.next = 11;\n                break;\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](1);\n                this.setState(types_1.ClientState.Failed);\n                throw _context7.t0;\n\n              case 11:\n                return _context7.abrupt(\"return\", contextId);\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[1, 7]]);\n      }));\n    }\n    /**\n     * Adds a listener for client state change events.\n     * @param cb - the callback to invoke on state change events.\n     */\n\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(cb) {\n      this.stateChangeCb = cb;\n    }\n    /**\n     * Adds a listener for current segment change events.\n     * @param cb - the callback to invoke on segment change events.\n     */\n\n  }, {\n    key: \"onSegmentChange\",\n    value: function onSegmentChange(cb) {\n      this.segmentChangeCb = cb;\n    }\n    /**\n     * Adds a listener for tentative transcript responses from the API.\n     * @param cb - the callback to invoke on a tentative transcript response.\n     */\n\n  }, {\n    key: \"onTentativeTranscript\",\n    value: function onTentativeTranscript(cb) {\n      this.tentativeTranscriptCb = cb;\n    }\n    /**\n     * Adds a listener for transcript responses from the API.\n     * @param cb - the callback to invoke on a transcript response.\n     */\n\n  }, {\n    key: \"onTranscript\",\n    value: function onTranscript(cb) {\n      this.transcriptCb = cb;\n    }\n    /**\n     * Adds a listener for tentative entities responses from the API.\n     * @param cb - the callback to invoke on a tentative entities response.\n     */\n\n  }, {\n    key: \"onTentativeEntities\",\n    value: function onTentativeEntities(cb) {\n      this.tentativeEntitiesCb = cb;\n    }\n    /**\n     * Adds a listener for entity responses from the API.\n     * @param cb - the callback to invoke on an entity response.\n     */\n\n  }, {\n    key: \"onEntity\",\n    value: function onEntity(cb) {\n      this.entityCb = cb;\n    }\n    /**\n     * Adds a listener for tentative intent responses from the API.\n     * @param cb - the callback to invoke on a tentative intent response.\n     */\n\n  }, {\n    key: \"onTentativeIntent\",\n    value: function onTentativeIntent(cb) {\n      this.tentativeIntentCb = cb;\n    }\n    /**\n     * Adds a listener for intent responses from the API.\n     * @param cb - the callback to invoke on an intent response.\n     */\n\n  }, {\n    key: \"onIntent\",\n    value: function onIntent(cb) {\n      this.intentCb = cb;\n    }\n  }, {\n    key: \"reconnectWebsocket\",\n    value: function reconnectWebsocket(deviceId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", async_retry_1.default(function (_, attempt) {\n                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n                    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            if (this.debug) {\n                              console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n                            } // await this.initializeWebsocket(deviceId)\n\n\n                          case 1:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8, this);\n                  }));\n                }, {\n                  retries: this.reconnectAttemptCount,\n                  minTimeout: this.reconnectMinDelay\n                }));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(newState) {\n      if (this.state === newState) {\n        return;\n      }\n\n      if (this.debug) {\n        console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n      }\n\n      this.state = newState;\n      this.stateChangeCb(newState);\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;\n\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n  var params = new URLSearchParams();\n  params.append('languageCode', languageCode);\n  params.append('sampleRate', sampleRate.toString());\n  return \"\".concat(baseUrl, \"?\").concat(params.toString());\n}","map":{"version":3,"sources":["../../src/speechly/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst locale_code_1 = __importDefault(require(\"locale-code\"));\nconst uuid_1 = require(\"uuid\");\nconst token_1 = require(\"../websocket/token\");\nconst microphone_1 = require(\"../microphone\");\nconst websocket_1 = require(\"../websocket\");\nconst storage_1 = require(\"../storage\");\nconst types_1 = require(\"./types\");\nconst state_1 = require(\"./state\");\nconst segment_1 = require(\"./segment\");\nconst parsers_1 = require(\"./parsers\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst deviceIdStorageKey = 'speechly-device-id';\nconst authTokenKey = 'speechly-auth-token';\nconst defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nconst defaultLoginUrl = 'https://api.speechly.com/login';\nconst defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\nclass Client {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        this.activeContexts = new Map();\n        this.reconnectAttemptCount = 5;\n        this.reconnectMinDelay = 1000;\n        this.contextStopDelay = 250;\n        this.state = types_1.ClientState.Disconnected;\n        this.stateChangeCb = () => { };\n        this.segmentChangeCb = () => { };\n        this.tentativeTranscriptCb = () => { };\n        this.tentativeEntitiesCb = () => { };\n        this.tentativeIntentCb = () => { };\n        this.transcriptCb = () => { };\n        this.entityCb = () => { };\n        this.intentCb = () => { };\n        this.handleWebsocketResponse = (response) => {\n            var _a;\n            if (this.debug) {\n                console.log('[SpeechlyClient]', 'Received response', response);\n            }\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            const { audio_context, segment_id, type } = response;\n            let { data } = response;\n            const context = this.activeContexts.get(audio_context);\n            if (context === undefined) {\n                console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n                return;\n            }\n            let segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n            switch (type) {\n                case websocket_1.WebsocketResponseType.TentativeTranscript:\n                    data = data;\n                    const words = parsers_1.parseTentativeTranscript(data);\n                    this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n                    segmentState = segmentState.updateTranscript(words);\n                    break;\n                case websocket_1.WebsocketResponseType.Transcript:\n                    data = data;\n                    const word = parsers_1.parseTranscript(data);\n                    this.transcriptCb(audio_context, segment_id, word);\n                    segmentState = segmentState.updateTranscript([word]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeEntities:\n                    data = data;\n                    const entities = parsers_1.parseTentativeEntities(data);\n                    this.tentativeEntitiesCb(audio_context, segment_id, entities);\n                    segmentState = segmentState.updateEntities(entities);\n                    break;\n                case websocket_1.WebsocketResponseType.Entity:\n                    data = data;\n                    const entity = parsers_1.parseEntity(data);\n                    this.entityCb(audio_context, segment_id, entity);\n                    segmentState = segmentState.updateEntities([entity]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeIntent:\n                    data = data;\n                    const tentativeIntent = parsers_1.parseIntent(data, false);\n                    this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n                    segmentState = segmentState.updateIntent(tentativeIntent);\n                    break;\n                case websocket_1.WebsocketResponseType.Intent:\n                    data = data;\n                    const intent = parsers_1.parseIntent(data, true);\n                    this.intentCb(audio_context, segment_id, intent);\n                    segmentState = segmentState.updateIntent(intent);\n                    break;\n                case websocket_1.WebsocketResponseType.SegmentEnd:\n                    segmentState = segmentState.finalize();\n                    break;\n                default:\n                // TODO: handle unexpected response types.\n            }\n            // Update the segment in current context.\n            context.set(segment_id, segmentState);\n            // Update current contexts.\n            this.activeContexts.set(audio_context, context);\n            // Log segment to console\n            if (this.logSegments) {\n                console.info(segmentState.toString());\n            }\n            // Fire segment change event.\n            this.segmentChangeCb(segmentState.toSegment());\n        };\n        this.handleWebsocketClosure = (err) => {\n            if (this.debug) {\n                console.error('[SpeechlyClient]', 'Server connection closed', err);\n            }\n            // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n            if (this.deviceId === undefined) {\n                this.setState(types_1.ClientState.Failed);\n                return;\n            }\n            // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n            if (this.state === types_1.ClientState.Connecting || this.state === types_1.ClientState.Failed) {\n                return;\n            }\n            this.setState(types_1.ClientState.Connecting);\n            this.reconnectWebsocket(this.deviceId)\n                .then(() => this.setState(types_1.ClientState.Connected))\n                .catch(() => this.setState(types_1.ClientState.Failed));\n        };\n        this.sampleRate = (_a = options.sampleRate) !== null && _a !== void 0 ? _a : microphone_1.DefaultSampleRate;\n        try {\n            const constraints = window.navigator.mediaDevices.getSupportedConstraints();\n            this.nativeResamplingSupported = constraints.sampleRate === true;\n        }\n        catch (_o) {\n            this.nativeResamplingSupported = false;\n        }\n        const language = (_b = options.language) !== null && _b !== void 0 ? _b : defaultLanguage;\n        if (!locale_code_1.default.validate(language)) {\n            throw Error(`[SpeechlyClient] Invalid language \"${language}\"`);\n        }\n        this.debug = (_c = options.debug) !== null && _c !== void 0 ? _c : false;\n        this.logSegments = (_d = options.logSegments) !== null && _d !== void 0 ? _d : false;\n        this.loginUrl = (_e = options.loginUrl) !== null && _e !== void 0 ? _e : defaultLoginUrl;\n        this.appId = (_f = options.appId) !== null && _f !== void 0 ? _f : undefined;\n        this.projectId = (_g = options.projectId) !== null && _g !== void 0 ? _g : undefined;\n        const apiUrl = generateWsUrl((_h = options.apiUrl) !== null && _h !== void 0 ? _h : defaultApiUrl, language, (_j = options.sampleRate) !== null && _j !== void 0 ? _j : microphone_1.DefaultSampleRate);\n        this.apiClient = (_k = options.apiClient) !== null && _k !== void 0 ? _k : new websocket_1.WebWorkerController();\n        this.storage = (_l = options.storage) !== null && _l !== void 0 ? _l : new storage_1.LocalStorage();\n        this.deviceId = this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n        const storedToken = this.storage.get(authTokenKey);\n        // 2. Fetch auth token. It doesn't matter if it's not present.\n        this.initializeApiClientPromise = new Promise(resolve => {\n            this.resolveInitialization = resolve;\n        });\n        if (storedToken == null || !token_1.validateToken(storedToken, this.projectId, this.appId, this.deviceId)) {\n            token_1.fetchToken(this.loginUrl, this.projectId, this.appId, this.deviceId)\n                .then(token => {\n                this.authToken = token;\n                // Cache the auth token in local storage for future use.\n                this.storage.set(authTokenKey, this.authToken);\n                this.connect(apiUrl);\n            })\n                .catch(err => {\n                throw err;\n            });\n        }\n        else {\n            this.authToken = storedToken;\n            this.connect(apiUrl);\n        }\n        if (window.AudioContext !== undefined) {\n            this.isWebkit = false;\n        }\n        else if (window.webkitAudioContext !== undefined) {\n            this.isWebkit = true;\n        }\n        else {\n            throw microphone_1.ErrDeviceNotSupported;\n        }\n        this.microphone = (_m = options.microphone) !== null && _m !== void 0 ? _m : new microphone_1.BrowserMicrophone(this.isWebkit, this.sampleRate, this.apiClient, this.debug);\n        this.apiClient.onResponse(this.handleWebsocketResponse);\n        this.apiClient.onClose(this.handleWebsocketClosure);\n        window.SpeechlyClient = this;\n    }\n    /**\n     * Esteblish websocket connection\n     */\n    connect(apiUrl) {\n        if (this.authToken != null) {\n            this.apiClient.initialize(apiUrl, this.authToken, this.sampleRate, this.debug).then(() => {\n                if (this.resolveInitialization != null) {\n                    this.resolveInitialization();\n                }\n            }).catch(err => {\n                throw err;\n            });\n        }\n    }\n    /**\n     * Initializes the client, by initializing the microphone and establishing connection to the API.\n     *\n     * This function HAS to be invoked by a user by e.g. binding it to a button press,\n     * or some other user-performed action.\n     *\n     * If this function is invoked without a user interaction,\n     * the microphone functionality will not work due to security restrictions by the browser.\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initializeApiClientPromise;\n            if (this.state !== types_1.ClientState.Disconnected) {\n                throw Error('Cannot initialize client - client is not in Disconnected state');\n            }\n            this.setState(types_1.ClientState.Connecting);\n            try {\n                // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n                // await this.storage.initialize()\n                // this.deviceId = await this.storage.getOrSet(deviceIdStorageKey, uuidv4)\n                // 2. Initialise the microphone stack.\n                if (this.isWebkit) {\n                    if (window.webkitAudioContext !== undefined) {\n                        // eslint-disable-next-line new-cap\n                        this.audioContext = new window.webkitAudioContext();\n                    }\n                }\n                else {\n                    const opts = {};\n                    if (this.nativeResamplingSupported) {\n                        opts.sampleRate = this.sampleRate;\n                    }\n                    this.audioContext = new window.AudioContext(opts);\n                }\n                const opts = {\n                    video: false,\n                };\n                if (this.nativeResamplingSupported) {\n                    opts.audio = {\n                        sampleRate: this.sampleRate,\n                    };\n                }\n                else {\n                    opts.audio = true;\n                }\n                if (this.audioContext != null) {\n                    // Start audio context if we are dealing with a WebKit browser.\n                    //\n                    // WebKit browsers (e.g. Safari) require to resume the context first,\n                    // before obtaining user media by calling `mediaDevices.getUserMedia`.\n                    //\n                    // If done in a different order, the audio context will resume successfully,\n                    // but will emit empty audio buffers.\n                    if (this.isWebkit) {\n                        yield this.audioContext.resume();\n                    }\n                    // 3. Initialise websocket.\n                    yield this.apiClient.setSourceSampleRate(this.audioContext.sampleRate);\n                    this.initializeMicrophonePromise = this.microphone.initialize(this.audioContext, opts);\n                    yield this.initializeMicrophonePromise;\n                }\n                else {\n                    throw microphone_1.ErrDeviceNotSupported;\n                }\n            }\n            catch (err) {\n                switch (err) {\n                    case microphone_1.ErrDeviceNotSupported:\n                        this.setState(types_1.ClientState.NoBrowserSupport);\n                        break;\n                    case microphone_1.ErrNoAudioConsent:\n                        this.setState(types_1.ClientState.NoAudioConsent);\n                        break;\n                    default:\n                        this.setState(types_1.ClientState.Failed);\n                }\n                throw err;\n            }\n            this.setState(types_1.ClientState.Connected);\n        });\n    }\n    /**\n     * Closes the client by closing the API connection and disabling the microphone.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const errs = [];\n            try {\n                yield this.microphone.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            try {\n                yield this.apiClient.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            this.activeContexts.clear();\n            this.setState(types_1.ClientState.Disconnected);\n            if (errs.length > 0) {\n                throw Error(errs.join(','));\n            }\n        });\n    }\n    /**\n     * Stops current context and immediately starts a new SLU context\n     * by sending a start context event to the API and unmuting the microphone.\n     * @param appId - unique identifier of an app in the dashboard.\n     */\n    switchContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === types_1.ClientState.Recording) {\n                this.resolveStopContext = undefined;\n                const contextId = yield this.apiClient.switchContext(appId);\n                this.activeContexts.set(contextId, new Map());\n            }\n        });\n    }\n    /**\n     * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n     * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n     */\n    startContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.resolveStopContext != null) {\n                this.resolveStopContext();\n                yield this.stoppedContextIdPromise;\n            }\n            if (this.state === types_1.ClientState.Disconnected || this.state === types_1.ClientState.Connecting) {\n                throw Error('Cannot start context - client is not connected');\n            }\n            this.setState(types_1.ClientState.Starting);\n            const contextId = yield this._startContext(appId);\n            return contextId;\n        });\n    }\n    _startContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let contextId;\n            try {\n                if (this.projectId != null) {\n                    contextId = yield this.apiClient.startContext(appId);\n                }\n                else {\n                    contextId = yield this.apiClient.startContext();\n                }\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Connected);\n                throw err;\n            }\n            this.setState(types_1.ClientState.Recording);\n            this.microphone.unmute();\n            this.activeContexts.set(contextId, new Map());\n            return contextId;\n        });\n    }\n    /**\n     * Stops current SLU context by sending a stop context event to the API and muting the microphone\n     * delayed by contextStopDelay = 250 ms\n     */\n    stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== types_1.ClientState.Recording && this.state !== types_1.ClientState.Starting) {\n                throw Error('Cannot stop context - client is not recording');\n            }\n            this.setState(types_1.ClientState.Stopping);\n            this.stoppedContextIdPromise = new Promise(resolve => {\n                Promise.race([\n                    new Promise(resolve => setTimeout(resolve, this.contextStopDelay)),\n                    new Promise(resolve => {\n                        this.resolveStopContext = resolve;\n                    }),\n                ])\n                    .then(() => {\n                    this._stopContext()\n                        .then(id => {\n                        resolve(id);\n                    })\n                        .catch(err => {\n                        throw err;\n                    });\n                })\n                    .catch(err => {\n                    throw err;\n                });\n            });\n            const contextId = yield this.stoppedContextIdPromise;\n            this.setState(types_1.ClientState.Connected);\n            this.activeContexts.delete(contextId);\n            return contextId;\n        });\n    }\n    _stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.microphone.mute();\n            let contextId;\n            try {\n                contextId = yield this.apiClient.stopContext();\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Failed);\n                throw err;\n            }\n            return contextId;\n        });\n    }\n    /**\n     * Adds a listener for client state change events.\n     * @param cb - the callback to invoke on state change events.\n     */\n    onStateChange(cb) {\n        this.stateChangeCb = cb;\n    }\n    /**\n     * Adds a listener for current segment change events.\n     * @param cb - the callback to invoke on segment change events.\n     */\n    onSegmentChange(cb) {\n        this.segmentChangeCb = cb;\n    }\n    /**\n     * Adds a listener for tentative transcript responses from the API.\n     * @param cb - the callback to invoke on a tentative transcript response.\n     */\n    onTentativeTranscript(cb) {\n        this.tentativeTranscriptCb = cb;\n    }\n    /**\n     * Adds a listener for transcript responses from the API.\n     * @param cb - the callback to invoke on a transcript response.\n     */\n    onTranscript(cb) {\n        this.transcriptCb = cb;\n    }\n    /**\n     * Adds a listener for tentative entities responses from the API.\n     * @param cb - the callback to invoke on a tentative entities response.\n     */\n    onTentativeEntities(cb) {\n        this.tentativeEntitiesCb = cb;\n    }\n    /**\n     * Adds a listener for entity responses from the API.\n     * @param cb - the callback to invoke on an entity response.\n     */\n    onEntity(cb) {\n        this.entityCb = cb;\n    }\n    /**\n     * Adds a listener for tentative intent responses from the API.\n     * @param cb - the callback to invoke on a tentative intent response.\n     */\n    onTentativeIntent(cb) {\n        this.tentativeIntentCb = cb;\n    }\n    /**\n     * Adds a listener for intent responses from the API.\n     * @param cb - the callback to invoke on an intent response.\n     */\n    onIntent(cb) {\n        this.intentCb = cb;\n    }\n    reconnectWebsocket(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return async_retry_1.default((_, attempt) => __awaiter(this, void 0, void 0, function* () {\n                if (this.debug) {\n                    console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n                }\n                // await this.initializeWebsocket(deviceId)\n            }), {\n                retries: this.reconnectAttemptCount,\n                minTimeout: this.reconnectMinDelay,\n            });\n        });\n    }\n    setState(newState) {\n        if (this.state === newState) {\n            return;\n        }\n        if (this.debug) {\n            console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n        }\n        this.state = newState;\n        this.stateChangeCb(newState);\n    }\n}\nexports.Client = Client;\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n    const params = new URLSearchParams();\n    params.append('languageCode', languageCode);\n    params.append('sampleRate', sampleRate.toString());\n    return `${baseUrl}?${params.toString()}`;\n}\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}