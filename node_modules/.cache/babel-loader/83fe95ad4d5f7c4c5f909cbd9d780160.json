{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst locale_code_1 = __importDefault(require(\"locale-code\"));\n\nconst uuid_1 = require(\"uuid\");\n\nconst token_1 = require(\"../websocket/token\");\n\nconst microphone_1 = require(\"../microphone\");\n\nconst websocket_1 = require(\"../websocket\");\n\nconst storage_1 = require(\"../storage\");\n\nconst types_1 = require(\"./types\");\n\nconst state_1 = require(\"./state\");\n\nconst segment_1 = require(\"./segment\");\n\nconst parsers_1 = require(\"./parsers\");\n\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\n\nconst deviceIdStorageKey = 'speechly-device-id';\nconst authTokenKey = 'speechly-auth-token';\nconst defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nconst defaultLoginUrl = 'https://api.speechly.com/login';\nconst defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\n\nclass Client {\n  constructor(options) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n\n    this.activeContexts = new Map();\n    this.reconnectAttemptCount = 5;\n    this.reconnectMinDelay = 1000;\n    this.contextStopDelay = 250;\n    this.state = types_1.ClientState.Disconnected;\n\n    this.stateChangeCb = () => {};\n\n    this.segmentChangeCb = () => {};\n\n    this.tentativeTranscriptCb = () => {};\n\n    this.tentativeEntitiesCb = () => {};\n\n    this.tentativeIntentCb = () => {};\n\n    this.transcriptCb = () => {};\n\n    this.entityCb = () => {};\n\n    this.intentCb = () => {};\n\n    this.handleWebsocketResponse = response => {\n      var _a;\n\n      if (this.debug) {\n        console.log('[SpeechlyClient]', 'Received response', response);\n      } // eslint-disable-next-line @typescript-eslint/camelcase\n\n\n      const {\n        audio_context,\n        segment_id,\n        type\n      } = response;\n      let {\n        data\n      } = response;\n      const context = this.activeContexts.get(audio_context);\n\n      if (context === undefined) {\n        console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n        return;\n      }\n\n      let segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n\n      switch (type) {\n        case websocket_1.WebsocketResponseType.TentativeTranscript:\n          data = data;\n          const words = parsers_1.parseTentativeTranscript(data);\n          this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n          segmentState = segmentState.updateTranscript(words);\n          break;\n\n        case websocket_1.WebsocketResponseType.Transcript:\n          data = data;\n          const word = parsers_1.parseTranscript(data);\n          this.transcriptCb(audio_context, segment_id, word);\n          segmentState = segmentState.updateTranscript([word]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeEntities:\n          data = data;\n          const entities = parsers_1.parseTentativeEntities(data);\n          this.tentativeEntitiesCb(audio_context, segment_id, entities);\n          segmentState = segmentState.updateEntities(entities);\n          break;\n\n        case websocket_1.WebsocketResponseType.Entity:\n          data = data;\n          const entity = parsers_1.parseEntity(data);\n          this.entityCb(audio_context, segment_id, entity);\n          segmentState = segmentState.updateEntities([entity]);\n          break;\n\n        case websocket_1.WebsocketResponseType.TentativeIntent:\n          data = data;\n          const tentativeIntent = parsers_1.parseIntent(data, false);\n          this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n          segmentState = segmentState.updateIntent(tentativeIntent);\n          break;\n\n        case websocket_1.WebsocketResponseType.Intent:\n          data = data;\n          const intent = parsers_1.parseIntent(data, true);\n          this.intentCb(audio_context, segment_id, intent);\n          segmentState = segmentState.updateIntent(intent);\n          break;\n\n        case websocket_1.WebsocketResponseType.SegmentEnd:\n          segmentState = segmentState.finalize();\n          break;\n\n        default: // TODO: handle unexpected response types.\n\n      } // Update the segment in current context.\n\n\n      context.set(segment_id, segmentState); // Update current contexts.\n\n      this.activeContexts.set(audio_context, context); // Log segment to console\n\n      if (this.logSegments) {\n        console.info(segmentState.toString());\n      } // Fire segment change event.\n\n\n      this.segmentChangeCb(segmentState.toSegment());\n    };\n\n    this.handleWebsocketClosure = err => {\n      if (this.debug) {\n        console.error('[SpeechlyClient]', 'Server connection closed', err);\n      } // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n\n\n      if (this.deviceId === undefined) {\n        this.setState(types_1.ClientState.Failed);\n        return;\n      } // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n\n\n      if (this.state === types_1.ClientState.Connecting || this.state === types_1.ClientState.Failed) {\n        return;\n      }\n\n      this.setState(types_1.ClientState.Connecting);\n      this.reconnectWebsocket(this.deviceId).then(() => this.setState(types_1.ClientState.Connected)).catch(() => this.setState(types_1.ClientState.Failed));\n    };\n\n    this.sampleRate = (_a = options.sampleRate) !== null && _a !== void 0 ? _a : microphone_1.DefaultSampleRate;\n\n    try {\n      const constraints = window.navigator.mediaDevices.getSupportedConstraints();\n      this.nativeResamplingSupported = constraints.sampleRate === true;\n    } catch (_o) {\n      this.nativeResamplingSupported = false;\n    }\n\n    const language = (_b = options.language) !== null && _b !== void 0 ? _b : defaultLanguage;\n\n    if (!locale_code_1.default.validate(language)) {\n      throw Error(`[SpeechlyClient] Invalid language \"${language}\"`);\n    }\n\n    this.debug = (_c = options.debug) !== null && _c !== void 0 ? _c : false;\n    this.logSegments = (_d = options.logSegments) !== null && _d !== void 0 ? _d : false;\n    this.loginUrl = (_e = options.loginUrl) !== null && _e !== void 0 ? _e : defaultLoginUrl;\n    this.appId = (_f = options.appId) !== null && _f !== void 0 ? _f : undefined;\n    this.projectId = (_g = options.projectId) !== null && _g !== void 0 ? _g : undefined;\n    const apiUrl = generateWsUrl((_h = options.apiUrl) !== null && _h !== void 0 ? _h : defaultApiUrl, language, (_j = options.sampleRate) !== null && _j !== void 0 ? _j : microphone_1.DefaultSampleRate);\n    this.apiClient = (_k = options.apiClient) !== null && _k !== void 0 ? _k : new websocket_1.WebWorkerController();\n    this.storage = (_l = options.storage) !== null && _l !== void 0 ? _l : new storage_1.LocalStorage();\n    this.deviceId = this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n    const storedToken = this.storage.get(authTokenKey); // 2. Fetch auth token. It doesn't matter if it's not present.\n\n    this.initializeApiClientPromise = new Promise(resolve => {\n      this.resolveInitialization = resolve;\n    });\n\n    if (storedToken == null || !token_1.validateToken(storedToken, this.projectId, this.appId, this.deviceId)) {\n      token_1.fetchToken(this.loginUrl, this.projectId, this.appId, this.deviceId).then(token => {\n        this.authToken = token; // Cache the auth token in local storage for future use.\n\n        this.storage.set(authTokenKey, this.authToken);\n        this.connect(apiUrl);\n      }).catch(err => {\n        throw err;\n      });\n    } else {\n      this.authToken = storedToken;\n      this.connect(apiUrl);\n    }\n\n    if (window.AudioContext !== undefined) {\n      this.isWebkit = false;\n    } else if (window.webkitAudioContext !== undefined) {\n      this.isWebkit = true;\n    } else {\n      throw microphone_1.ErrDeviceNotSupported;\n    }\n\n    this.microphone = (_m = options.microphone) !== null && _m !== void 0 ? _m : new microphone_1.BrowserMicrophone(this.isWebkit, this.sampleRate, this.apiClient, this.debug);\n    this.apiClient.onResponse(this.handleWebsocketResponse);\n    this.apiClient.onClose(this.handleWebsocketClosure);\n    window.SpeechlyClient = this;\n  }\n  /**\n   * Esteblish websocket connection\n   */\n\n\n  connect(apiUrl) {\n    if (this.authToken != null) {\n      this.apiClient.initialize(apiUrl, this.authToken, this.sampleRate, this.debug).then(() => {\n        if (this.resolveInitialization != null) {\n          this.resolveInitialization();\n        }\n      }).catch(err => {\n        throw err;\n      });\n    }\n  }\n  /**\n   * Initializes the client, by initializing the microphone and establishing connection to the API.\n   *\n   * This function HAS to be invoked by a user by e.g. binding it to a button press,\n   * or some other user-performed action.\n   *\n   * If this function is invoked without a user interaction,\n   * the microphone functionality will not work due to security restrictions by the browser.\n   */\n\n\n  initialize() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.initializeApiClientPromise;\n\n      if (this.state !== types_1.ClientState.Disconnected) {\n        throw Error('Cannot initialize client - client is not in Disconnected state');\n      }\n\n      this.setState(types_1.ClientState.Connecting);\n\n      try {\n        // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n        // await this.storage.initialize()\n        // this.deviceId = await this.storage.getOrSet(deviceIdStorageKey, uuidv4)\n        // 2. Initialise the microphone stack.\n        if (this.isWebkit) {\n          if (window.webkitAudioContext !== undefined) {\n            // eslint-disable-next-line new-cap\n            this.audioContext = new window.webkitAudioContext();\n          }\n        } else {\n          const opts = {};\n\n          if (this.nativeResamplingSupported) {\n            opts.sampleRate = this.sampleRate;\n          }\n\n          this.audioContext = new window.AudioContext(opts);\n        }\n\n        const opts = {\n          video: false\n        };\n\n        if (this.nativeResamplingSupported) {\n          opts.audio = {\n            sampleRate: this.sampleRate\n          };\n        } else {\n          opts.audio = true;\n        }\n\n        if (this.audioContext != null) {\n          // Start audio context if we are dealing with a WebKit browser.\n          //\n          // WebKit browsers (e.g. Safari) require to resume the context first,\n          // before obtaining user media by calling `mediaDevices.getUserMedia`.\n          //\n          // If done in a different order, the audio context will resume successfully,\n          // but will emit empty audio buffers.\n          if (this.isWebkit) {\n            yield this.audioContext.resume();\n          } // 3. Initialise websocket.\n\n\n          yield this.apiClient.setSourceSampleRate(this.audioContext.sampleRate);\n          this.initializeMicrophonePromise = this.microphone.initialize(this.audioContext, opts);\n          yield this.initializeMicrophonePromise;\n        } else {\n          throw microphone_1.ErrDeviceNotSupported;\n        }\n      } catch (err) {\n        switch (err) {\n          case microphone_1.ErrDeviceNotSupported:\n            this.setState(types_1.ClientState.NoBrowserSupport);\n            break;\n\n          case microphone_1.ErrNoAudioConsent:\n            this.setState(types_1.ClientState.NoAudioConsent);\n            break;\n\n          default:\n            this.setState(types_1.ClientState.Failed);\n        }\n\n        throw err;\n      }\n\n      this.setState(types_1.ClientState.Connected);\n    });\n  }\n  /**\n   * Closes the client by closing the API connection and disabling the microphone.\n   */\n\n\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const errs = [];\n\n      try {\n        yield this.microphone.close();\n      } catch (err) {\n        errs.push(err.message);\n      }\n\n      try {\n        yield this.apiClient.close();\n      } catch (err) {\n        errs.push(err.message);\n      }\n\n      this.activeContexts.clear();\n      this.setState(types_1.ClientState.Disconnected);\n\n      if (errs.length > 0) {\n        throw Error(errs.join(','));\n      }\n    });\n  }\n  /**\n   * Stops current context and immediately starts a new SLU context\n   * by sending a start context event to the API and unmuting the microphone.\n   * @param appId - unique identifier of an app in the dashboard.\n   */\n\n\n  switchContext(appId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === types_1.ClientState.Recording) {\n        this.resolveStopContext = undefined;\n        const contextId = yield this.apiClient.switchContext(appId);\n        this.activeContexts.set(contextId, new Map());\n      }\n    });\n  }\n  /**\n   * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n   * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n   */\n\n\n  startContext(appId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.resolveStopContext != null) {\n        this.resolveStopContext();\n        yield this.stoppedContextIdPromise;\n      }\n\n      if (this.state === types_1.ClientState.Disconnected || this.state === types_1.ClientState.Connecting) {\n        throw Error('Cannot start context - client is not connected');\n      }\n\n      this.setState(types_1.ClientState.Starting);\n      const contextId = yield this._startContext(appId);\n      return contextId;\n    });\n  }\n\n  _startContext(appId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let contextId;\n\n      try {\n        if (this.projectId != null) {\n          contextId = yield this.apiClient.startContext(appId);\n        } else {\n          contextId = yield this.apiClient.startContext();\n        }\n      } catch (err) {\n        this.setState(types_1.ClientState.Connected);\n        throw err;\n      }\n\n      this.setState(types_1.ClientState.Recording);\n      this.microphone.unmute();\n      this.activeContexts.set(contextId, new Map());\n      return contextId;\n    });\n  }\n  /**\n   * Stops current SLU context by sending a stop context event to the API and muting the microphone\n   * delayed by contextStopDelay = 250 ms\n   */\n\n\n  stopContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state !== types_1.ClientState.Recording && this.state !== types_1.ClientState.Starting) {\n        throw Error('Cannot stop context - client is not recording');\n      }\n\n      this.setState(types_1.ClientState.Stopping);\n      this.stoppedContextIdPromise = new Promise(resolve => {\n        Promise.race([new Promise(resolve => setTimeout(resolve, this.contextStopDelay)), new Promise(resolve => {\n          this.resolveStopContext = resolve;\n        })]).then(() => {\n          this._stopContext().then(id => {\n            resolve(id);\n          }).catch(err => {\n            throw err;\n          });\n        }).catch(err => {\n          throw err;\n        });\n      });\n      const contextId = yield this.stoppedContextIdPromise;\n      this.setState(types_1.ClientState.Connected);\n      this.activeContexts.delete(contextId);\n      return contextId;\n    });\n  }\n\n  _stopContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.microphone.mute();\n      let contextId;\n\n      try {\n        contextId = yield this.apiClient.stopContext();\n      } catch (err) {\n        this.setState(types_1.ClientState.Failed);\n        throw err;\n      }\n\n      return contextId;\n    });\n  }\n  /**\n   * Adds a listener for client state change events.\n   * @param cb - the callback to invoke on state change events.\n   */\n\n\n  onStateChange(cb) {\n    this.stateChangeCb = cb;\n  }\n  /**\n   * Adds a listener for current segment change events.\n   * @param cb - the callback to invoke on segment change events.\n   */\n\n\n  onSegmentChange(cb) {\n    this.segmentChangeCb = cb;\n  }\n  /**\n   * Adds a listener for tentative transcript responses from the API.\n   * @param cb - the callback to invoke on a tentative transcript response.\n   */\n\n\n  onTentativeTranscript(cb) {\n    this.tentativeTranscriptCb = cb;\n  }\n  /**\n   * Adds a listener for transcript responses from the API.\n   * @param cb - the callback to invoke on a transcript response.\n   */\n\n\n  onTranscript(cb) {\n    this.transcriptCb = cb;\n  }\n  /**\n   * Adds a listener for tentative entities responses from the API.\n   * @param cb - the callback to invoke on a tentative entities response.\n   */\n\n\n  onTentativeEntities(cb) {\n    this.tentativeEntitiesCb = cb;\n  }\n  /**\n   * Adds a listener for entity responses from the API.\n   * @param cb - the callback to invoke on an entity response.\n   */\n\n\n  onEntity(cb) {\n    this.entityCb = cb;\n  }\n  /**\n   * Adds a listener for tentative intent responses from the API.\n   * @param cb - the callback to invoke on a tentative intent response.\n   */\n\n\n  onTentativeIntent(cb) {\n    this.tentativeIntentCb = cb;\n  }\n  /**\n   * Adds a listener for intent responses from the API.\n   * @param cb - the callback to invoke on an intent response.\n   */\n\n\n  onIntent(cb) {\n    this.intentCb = cb;\n  }\n\n  reconnectWebsocket(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return async_retry_1.default((_, attempt) => __awaiter(this, void 0, void 0, function* () {\n        if (this.debug) {\n          console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n        } // await this.initializeWebsocket(deviceId)\n\n      }), {\n        retries: this.reconnectAttemptCount,\n        minTimeout: this.reconnectMinDelay\n      });\n    });\n  }\n\n  setState(newState) {\n    if (this.state === newState) {\n      return;\n    }\n\n    if (this.debug) {\n      console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n    }\n\n    this.state = newState;\n    this.stateChangeCb(newState);\n  }\n\n}\n\nexports.Client = Client;\n\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n  const params = new URLSearchParams();\n  params.append('languageCode', languageCode);\n  params.append('sampleRate', sampleRate.toString());\n  return `${baseUrl}?${params.toString()}`;\n}","map":{"version":3,"sources":["../../src/speechly/client.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst locale_code_1 = __importDefault(require(\"locale-code\"));\nconst uuid_1 = require(\"uuid\");\nconst token_1 = require(\"../websocket/token\");\nconst microphone_1 = require(\"../microphone\");\nconst websocket_1 = require(\"../websocket\");\nconst storage_1 = require(\"../storage\");\nconst types_1 = require(\"./types\");\nconst state_1 = require(\"./state\");\nconst segment_1 = require(\"./segment\");\nconst parsers_1 = require(\"./parsers\");\nconst async_retry_1 = __importDefault(require(\"async-retry\"));\nconst deviceIdStorageKey = 'speechly-device-id';\nconst authTokenKey = 'speechly-auth-token';\nconst defaultApiUrl = 'wss://api.speechly.com/ws/v1';\nconst defaultLoginUrl = 'https://api.speechly.com/login';\nconst defaultLanguage = 'en-US';\n/**\n * A client for Speechly Spoken Language Understanding (SLU) API. The client handles initializing the microphone\n * and websocket connection to Speechly API, passing control events and audio stream to the API, reading the responses\n * and dispatching them, as well as providing a high-level API for interacting with so-called speech segments.\n * @public\n */\nclass Client {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        this.activeContexts = new Map();\n        this.reconnectAttemptCount = 5;\n        this.reconnectMinDelay = 1000;\n        this.contextStopDelay = 250;\n        this.state = types_1.ClientState.Disconnected;\n        this.stateChangeCb = () => { };\n        this.segmentChangeCb = () => { };\n        this.tentativeTranscriptCb = () => { };\n        this.tentativeEntitiesCb = () => { };\n        this.tentativeIntentCb = () => { };\n        this.transcriptCb = () => { };\n        this.entityCb = () => { };\n        this.intentCb = () => { };\n        this.handleWebsocketResponse = (response) => {\n            var _a;\n            if (this.debug) {\n                console.log('[SpeechlyClient]', 'Received response', response);\n            }\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            const { audio_context, segment_id, type } = response;\n            let { data } = response;\n            const context = this.activeContexts.get(audio_context);\n            if (context === undefined) {\n                console.warn('[SpeechlyClient]', 'Received response for non-existent context', audio_context);\n                return;\n            }\n            let segmentState = (_a = context.get(segment_id)) !== null && _a !== void 0 ? _a : new segment_1.SegmentState(audio_context, segment_id);\n            switch (type) {\n                case websocket_1.WebsocketResponseType.TentativeTranscript:\n                    data = data;\n                    const words = parsers_1.parseTentativeTranscript(data);\n                    this.tentativeTranscriptCb(audio_context, segment_id, words, data.transcript);\n                    segmentState = segmentState.updateTranscript(words);\n                    break;\n                case websocket_1.WebsocketResponseType.Transcript:\n                    data = data;\n                    const word = parsers_1.parseTranscript(data);\n                    this.transcriptCb(audio_context, segment_id, word);\n                    segmentState = segmentState.updateTranscript([word]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeEntities:\n                    data = data;\n                    const entities = parsers_1.parseTentativeEntities(data);\n                    this.tentativeEntitiesCb(audio_context, segment_id, entities);\n                    segmentState = segmentState.updateEntities(entities);\n                    break;\n                case websocket_1.WebsocketResponseType.Entity:\n                    data = data;\n                    const entity = parsers_1.parseEntity(data);\n                    this.entityCb(audio_context, segment_id, entity);\n                    segmentState = segmentState.updateEntities([entity]);\n                    break;\n                case websocket_1.WebsocketResponseType.TentativeIntent:\n                    data = data;\n                    const tentativeIntent = parsers_1.parseIntent(data, false);\n                    this.tentativeIntentCb(audio_context, segment_id, tentativeIntent);\n                    segmentState = segmentState.updateIntent(tentativeIntent);\n                    break;\n                case websocket_1.WebsocketResponseType.Intent:\n                    data = data;\n                    const intent = parsers_1.parseIntent(data, true);\n                    this.intentCb(audio_context, segment_id, intent);\n                    segmentState = segmentState.updateIntent(intent);\n                    break;\n                case websocket_1.WebsocketResponseType.SegmentEnd:\n                    segmentState = segmentState.finalize();\n                    break;\n                default:\n                // TODO: handle unexpected response types.\n            }\n            // Update the segment in current context.\n            context.set(segment_id, segmentState);\n            // Update current contexts.\n            this.activeContexts.set(audio_context, context);\n            // Log segment to console\n            if (this.logSegments) {\n                console.info(segmentState.toString());\n            }\n            // Fire segment change event.\n            this.segmentChangeCb(segmentState.toSegment());\n        };\n        this.handleWebsocketClosure = (err) => {\n            if (this.debug) {\n                console.error('[SpeechlyClient]', 'Server connection closed', err);\n            }\n            // If for some reason deviceId is missing, there's nothing else we can do but fail completely.\n            if (this.deviceId === undefined) {\n                this.setState(types_1.ClientState.Failed);\n                return;\n            }\n            // Make sure we don't have concurrent reconnection procedures or attempt to reconnect from a failed state.\n            if (this.state === types_1.ClientState.Connecting || this.state === types_1.ClientState.Failed) {\n                return;\n            }\n            this.setState(types_1.ClientState.Connecting);\n            this.reconnectWebsocket(this.deviceId)\n                .then(() => this.setState(types_1.ClientState.Connected))\n                .catch(() => this.setState(types_1.ClientState.Failed));\n        };\n        this.sampleRate = (_a = options.sampleRate) !== null && _a !== void 0 ? _a : microphone_1.DefaultSampleRate;\n        try {\n            const constraints = window.navigator.mediaDevices.getSupportedConstraints();\n            this.nativeResamplingSupported = constraints.sampleRate === true;\n        }\n        catch (_o) {\n            this.nativeResamplingSupported = false;\n        }\n        const language = (_b = options.language) !== null && _b !== void 0 ? _b : defaultLanguage;\n        if (!locale_code_1.default.validate(language)) {\n            throw Error(`[SpeechlyClient] Invalid language \"${language}\"`);\n        }\n        this.debug = (_c = options.debug) !== null && _c !== void 0 ? _c : false;\n        this.logSegments = (_d = options.logSegments) !== null && _d !== void 0 ? _d : false;\n        this.loginUrl = (_e = options.loginUrl) !== null && _e !== void 0 ? _e : defaultLoginUrl;\n        this.appId = (_f = options.appId) !== null && _f !== void 0 ? _f : undefined;\n        this.projectId = (_g = options.projectId) !== null && _g !== void 0 ? _g : undefined;\n        const apiUrl = generateWsUrl((_h = options.apiUrl) !== null && _h !== void 0 ? _h : defaultApiUrl, language, (_j = options.sampleRate) !== null && _j !== void 0 ? _j : microphone_1.DefaultSampleRate);\n        this.apiClient = (_k = options.apiClient) !== null && _k !== void 0 ? _k : new websocket_1.WebWorkerController();\n        this.storage = (_l = options.storage) !== null && _l !== void 0 ? _l : new storage_1.LocalStorage();\n        this.deviceId = this.storage.getOrSet(deviceIdStorageKey, uuid_1.v4);\n        const storedToken = this.storage.get(authTokenKey);\n        // 2. Fetch auth token. It doesn't matter if it's not present.\n        this.initializeApiClientPromise = new Promise(resolve => {\n            this.resolveInitialization = resolve;\n        });\n        if (storedToken == null || !token_1.validateToken(storedToken, this.projectId, this.appId, this.deviceId)) {\n            token_1.fetchToken(this.loginUrl, this.projectId, this.appId, this.deviceId)\n                .then(token => {\n                this.authToken = token;\n                // Cache the auth token in local storage for future use.\n                this.storage.set(authTokenKey, this.authToken);\n                this.connect(apiUrl);\n            })\n                .catch(err => {\n                throw err;\n            });\n        }\n        else {\n            this.authToken = storedToken;\n            this.connect(apiUrl);\n        }\n        if (window.AudioContext !== undefined) {\n            this.isWebkit = false;\n        }\n        else if (window.webkitAudioContext !== undefined) {\n            this.isWebkit = true;\n        }\n        else {\n            throw microphone_1.ErrDeviceNotSupported;\n        }\n        this.microphone = (_m = options.microphone) !== null && _m !== void 0 ? _m : new microphone_1.BrowserMicrophone(this.isWebkit, this.sampleRate, this.apiClient, this.debug);\n        this.apiClient.onResponse(this.handleWebsocketResponse);\n        this.apiClient.onClose(this.handleWebsocketClosure);\n        window.SpeechlyClient = this;\n    }\n    /**\n     * Esteblish websocket connection\n     */\n    connect(apiUrl) {\n        if (this.authToken != null) {\n            this.apiClient.initialize(apiUrl, this.authToken, this.sampleRate, this.debug).then(() => {\n                if (this.resolveInitialization != null) {\n                    this.resolveInitialization();\n                }\n            }).catch(err => {\n                throw err;\n            });\n        }\n    }\n    /**\n     * Initializes the client, by initializing the microphone and establishing connection to the API.\n     *\n     * This function HAS to be invoked by a user by e.g. binding it to a button press,\n     * or some other user-performed action.\n     *\n     * If this function is invoked without a user interaction,\n     * the microphone functionality will not work due to security restrictions by the browser.\n     */\n    initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.initializeApiClientPromise;\n            if (this.state !== types_1.ClientState.Disconnected) {\n                throw Error('Cannot initialize client - client is not in Disconnected state');\n            }\n            this.setState(types_1.ClientState.Connecting);\n            try {\n                // 1. Initialise the storage and fetch deviceId (or generate new one and store it).\n                // await this.storage.initialize()\n                // this.deviceId = await this.storage.getOrSet(deviceIdStorageKey, uuidv4)\n                // 2. Initialise the microphone stack.\n                if (this.isWebkit) {\n                    if (window.webkitAudioContext !== undefined) {\n                        // eslint-disable-next-line new-cap\n                        this.audioContext = new window.webkitAudioContext();\n                    }\n                }\n                else {\n                    const opts = {};\n                    if (this.nativeResamplingSupported) {\n                        opts.sampleRate = this.sampleRate;\n                    }\n                    this.audioContext = new window.AudioContext(opts);\n                }\n                const opts = {\n                    video: false,\n                };\n                if (this.nativeResamplingSupported) {\n                    opts.audio = {\n                        sampleRate: this.sampleRate,\n                    };\n                }\n                else {\n                    opts.audio = true;\n                }\n                if (this.audioContext != null) {\n                    // Start audio context if we are dealing with a WebKit browser.\n                    //\n                    // WebKit browsers (e.g. Safari) require to resume the context first,\n                    // before obtaining user media by calling `mediaDevices.getUserMedia`.\n                    //\n                    // If done in a different order, the audio context will resume successfully,\n                    // but will emit empty audio buffers.\n                    if (this.isWebkit) {\n                        yield this.audioContext.resume();\n                    }\n                    // 3. Initialise websocket.\n                    yield this.apiClient.setSourceSampleRate(this.audioContext.sampleRate);\n                    this.initializeMicrophonePromise = this.microphone.initialize(this.audioContext, opts);\n                    yield this.initializeMicrophonePromise;\n                }\n                else {\n                    throw microphone_1.ErrDeviceNotSupported;\n                }\n            }\n            catch (err) {\n                switch (err) {\n                    case microphone_1.ErrDeviceNotSupported:\n                        this.setState(types_1.ClientState.NoBrowserSupport);\n                        break;\n                    case microphone_1.ErrNoAudioConsent:\n                        this.setState(types_1.ClientState.NoAudioConsent);\n                        break;\n                    default:\n                        this.setState(types_1.ClientState.Failed);\n                }\n                throw err;\n            }\n            this.setState(types_1.ClientState.Connected);\n        });\n    }\n    /**\n     * Closes the client by closing the API connection and disabling the microphone.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const errs = [];\n            try {\n                yield this.microphone.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            try {\n                yield this.apiClient.close();\n            }\n            catch (err) {\n                errs.push(err.message);\n            }\n            this.activeContexts.clear();\n            this.setState(types_1.ClientState.Disconnected);\n            if (errs.length > 0) {\n                throw Error(errs.join(','));\n            }\n        });\n    }\n    /**\n     * Stops current context and immediately starts a new SLU context\n     * by sending a start context event to the API and unmuting the microphone.\n     * @param appId - unique identifier of an app in the dashboard.\n     */\n    switchContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === types_1.ClientState.Recording) {\n                this.resolveStopContext = undefined;\n                const contextId = yield this.apiClient.switchContext(appId);\n                this.activeContexts.set(contextId, new Map());\n            }\n        });\n    }\n    /**\n     * Starts a new SLU context by sending a start context event to the API and unmuting the microphone.\n     * @param cb - the callback which is invoked when the context start was acknowledged by the API.\n     */\n    startContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.resolveStopContext != null) {\n                this.resolveStopContext();\n                yield this.stoppedContextIdPromise;\n            }\n            if (this.state === types_1.ClientState.Disconnected || this.state === types_1.ClientState.Connecting) {\n                throw Error('Cannot start context - client is not connected');\n            }\n            this.setState(types_1.ClientState.Starting);\n            const contextId = yield this._startContext(appId);\n            return contextId;\n        });\n    }\n    _startContext(appId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let contextId;\n            try {\n                if (this.projectId != null) {\n                    contextId = yield this.apiClient.startContext(appId);\n                }\n                else {\n                    contextId = yield this.apiClient.startContext();\n                }\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Connected);\n                throw err;\n            }\n            this.setState(types_1.ClientState.Recording);\n            this.microphone.unmute();\n            this.activeContexts.set(contextId, new Map());\n            return contextId;\n        });\n    }\n    /**\n     * Stops current SLU context by sending a stop context event to the API and muting the microphone\n     * delayed by contextStopDelay = 250 ms\n     */\n    stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state !== types_1.ClientState.Recording && this.state !== types_1.ClientState.Starting) {\n                throw Error('Cannot stop context - client is not recording');\n            }\n            this.setState(types_1.ClientState.Stopping);\n            this.stoppedContextIdPromise = new Promise(resolve => {\n                Promise.race([\n                    new Promise(resolve => setTimeout(resolve, this.contextStopDelay)),\n                    new Promise(resolve => {\n                        this.resolveStopContext = resolve;\n                    }),\n                ])\n                    .then(() => {\n                    this._stopContext()\n                        .then(id => {\n                        resolve(id);\n                    })\n                        .catch(err => {\n                        throw err;\n                    });\n                })\n                    .catch(err => {\n                    throw err;\n                });\n            });\n            const contextId = yield this.stoppedContextIdPromise;\n            this.setState(types_1.ClientState.Connected);\n            this.activeContexts.delete(contextId);\n            return contextId;\n        });\n    }\n    _stopContext() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.microphone.mute();\n            let contextId;\n            try {\n                contextId = yield this.apiClient.stopContext();\n            }\n            catch (err) {\n                this.setState(types_1.ClientState.Failed);\n                throw err;\n            }\n            return contextId;\n        });\n    }\n    /**\n     * Adds a listener for client state change events.\n     * @param cb - the callback to invoke on state change events.\n     */\n    onStateChange(cb) {\n        this.stateChangeCb = cb;\n    }\n    /**\n     * Adds a listener for current segment change events.\n     * @param cb - the callback to invoke on segment change events.\n     */\n    onSegmentChange(cb) {\n        this.segmentChangeCb = cb;\n    }\n    /**\n     * Adds a listener for tentative transcript responses from the API.\n     * @param cb - the callback to invoke on a tentative transcript response.\n     */\n    onTentativeTranscript(cb) {\n        this.tentativeTranscriptCb = cb;\n    }\n    /**\n     * Adds a listener for transcript responses from the API.\n     * @param cb - the callback to invoke on a transcript response.\n     */\n    onTranscript(cb) {\n        this.transcriptCb = cb;\n    }\n    /**\n     * Adds a listener for tentative entities responses from the API.\n     * @param cb - the callback to invoke on a tentative entities response.\n     */\n    onTentativeEntities(cb) {\n        this.tentativeEntitiesCb = cb;\n    }\n    /**\n     * Adds a listener for entity responses from the API.\n     * @param cb - the callback to invoke on an entity response.\n     */\n    onEntity(cb) {\n        this.entityCb = cb;\n    }\n    /**\n     * Adds a listener for tentative intent responses from the API.\n     * @param cb - the callback to invoke on a tentative intent response.\n     */\n    onTentativeIntent(cb) {\n        this.tentativeIntentCb = cb;\n    }\n    /**\n     * Adds a listener for intent responses from the API.\n     * @param cb - the callback to invoke on an intent response.\n     */\n    onIntent(cb) {\n        this.intentCb = cb;\n    }\n    reconnectWebsocket(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return async_retry_1.default((_, attempt) => __awaiter(this, void 0, void 0, function* () {\n                if (this.debug) {\n                    console.log('[SpeechlyClient]', 'WebSocket reconnection attempt number:', attempt);\n                }\n                // await this.initializeWebsocket(deviceId)\n            }), {\n                retries: this.reconnectAttemptCount,\n                minTimeout: this.reconnectMinDelay,\n            });\n        });\n    }\n    setState(newState) {\n        if (this.state === newState) {\n            return;\n        }\n        if (this.debug) {\n            console.log('[SpeechlyClient]', 'State transition', state_1.stateToString(this.state), state_1.stateToString(newState));\n        }\n        this.state = newState;\n        this.stateChangeCb(newState);\n    }\n}\nexports.Client = Client;\nfunction generateWsUrl(baseUrl, languageCode, sampleRate) {\n    const params = new URLSearchParams();\n    params.append('languageCode', languageCode);\n    params.append('sampleRate', sampleRate.toString());\n    return `${baseUrl}?${params.toString()}`;\n}\n//# sourceMappingURL=client.js.map"]},"metadata":{},"sourceType":"script"}