{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass SegmentState {\n  constructor(ctxId, sId) {\n    this.isFinalized = false;\n    this.words = [];\n    this.entities = new Map();\n    this.intent = {\n      intent: '',\n      isFinal: false\n    };\n    this.contextId = ctxId;\n    this.id = sId;\n  }\n\n  toSegment() {\n    let i = 0;\n    const entities = new Array(this.entities.size);\n    this.entities.forEach(v => {\n      entities[i] = v;\n      i++;\n    });\n    return {\n      id: this.id,\n      contextId: this.contextId,\n      isFinal: this.isFinalized,\n      words: this.words,\n      entities: entities,\n      intent: this.intent\n    };\n  }\n\n  toString() {\n    const segment = this.toSegment();\n    const words = segment.words.filter(w => w.value).map(w => ({\n      value: w.value,\n      index: w.index\n    }));\n    const cleanSegment = Object.assign(Object.assign({}, segment), {\n      words\n    });\n    return JSON.stringify(cleanSegment, null, 2);\n  }\n\n  updateTranscript(words) {\n    words.forEach(w => {\n      // Only accept tentative words if the segment is tentative.\n      if (!this.isFinalized || w.isFinal) {\n        this.words[w.index] = w;\n      }\n    });\n    return this;\n  }\n\n  updateEntities(entities) {\n    entities.forEach(e => {\n      // Only accept tentative entities if the segment is tentative.\n      if (!this.isFinalized || e.isFinal) {\n        this.entities.set(entityMapKey(e), e);\n      }\n    });\n    return this;\n  }\n\n  updateIntent(intent) {\n    // Only accept tentative intent if the segment is tentative.\n    if (!this.isFinalized || intent.isFinal) {\n      this.intent = intent;\n    }\n\n    return this;\n  }\n\n  finalize() {\n    // Filter away any entities which were not finalized.\n    this.entities.forEach((val, key) => {\n      if (!val.isFinal) {\n        this.entities.delete(key);\n      }\n    }); // Filter away any transcripts which were not finalized.\n\n    this.words = this.words.filter(w => w.isFinal);\n\n    if (!this.intent.isFinal) {\n      this.intent.intent = '';\n      this.intent.isFinal = true;\n    } // Mark as final.\n\n\n    this.isFinalized = true;\n    return this;\n  }\n\n}\n\nexports.SegmentState = SegmentState;\n\nfunction entityMapKey(e) {\n  return `${e.startPosition.toString()}:${e.endPosition.toString()}`;\n}","map":{"version":3,"sources":["../../src/speechly/segment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SegmentState {\n    constructor(ctxId, sId) {\n        this.isFinalized = false;\n        this.words = [];\n        this.entities = new Map();\n        this.intent = { intent: '', isFinal: false };\n        this.contextId = ctxId;\n        this.id = sId;\n    }\n    toSegment() {\n        let i = 0;\n        const entities = new Array(this.entities.size);\n        this.entities.forEach(v => {\n            entities[i] = v;\n            i++;\n        });\n        return {\n            id: this.id,\n            contextId: this.contextId,\n            isFinal: this.isFinalized,\n            words: this.words,\n            entities: entities,\n            intent: this.intent,\n        };\n    }\n    toString() {\n        const segment = this.toSegment();\n        const words = segment.words.filter((w) => w.value).map((w) => ({ value: w.value, index: w.index }));\n        const cleanSegment = Object.assign(Object.assign({}, segment), { words });\n        return JSON.stringify(cleanSegment, null, 2);\n    }\n    updateTranscript(words) {\n        words.forEach(w => {\n            // Only accept tentative words if the segment is tentative.\n            if (!this.isFinalized || w.isFinal) {\n                this.words[w.index] = w;\n            }\n        });\n        return this;\n    }\n    updateEntities(entities) {\n        entities.forEach(e => {\n            // Only accept tentative entities if the segment is tentative.\n            if (!this.isFinalized || e.isFinal) {\n                this.entities.set(entityMapKey(e), e);\n            }\n        });\n        return this;\n    }\n    updateIntent(intent) {\n        // Only accept tentative intent if the segment is tentative.\n        if (!this.isFinalized || intent.isFinal) {\n            this.intent = intent;\n        }\n        return this;\n    }\n    finalize() {\n        // Filter away any entities which were not finalized.\n        this.entities.forEach((val, key) => {\n            if (!val.isFinal) {\n                this.entities.delete(key);\n            }\n        });\n        // Filter away any transcripts which were not finalized.\n        this.words = this.words.filter(w => w.isFinal);\n        if (!this.intent.isFinal) {\n            this.intent.intent = '';\n            this.intent.isFinal = true;\n        }\n        // Mark as final.\n        this.isFinalized = true;\n        return this;\n    }\n}\nexports.SegmentState = SegmentState;\nfunction entityMapKey(e) {\n    return `${e.startPosition.toString()}:${e.endPosition.toString()}`;\n}\n//# sourceMappingURL=segment.js.map"]},"metadata":{},"sourceType":"script"}